/**
 * 解题技巧管理
 * @file useTechniques.js
 */
import { ref } from 'vue';

/**
 * 解题技巧管理
 * @returns {Object} 技巧相关状态和方法
 */
export function useTechniques() {
  // 当前选中的技巧索引
  const currentTechniqueIndex = ref(0);

  // 解题技巧列表
  const techniques = [
    {
      name: "唯一候选数法",
      difficulty: 1,
      description: `
        <p>唯一候选数法是最基本的数独解题技巧，也称为"排除法"。当一个单元格只有一个可能的数字时，这个数字就是该单元格的唯一解。</p>
        <p>步骤：</p>
        <ol>
          <li>找出每个空白单元格的所有可能数字（候选数）</li>
          <li>如果某个单元格只有一个候选数，则该数字就是该单元格的解</li>
        </ol>
        <p>这是最直观的解题方法，适合初学者。</p>
      `,
      example: `
        <p>例如，如果一个单元格的候选数只有5，那么这个单元格就应该填入5。</p>
      `
    },
    {
      name: "隐性唯一候选数法",
      difficulty: 2,
      description: `
        <p>隐性唯一候选数法是指在某一行、列或宫格中，某个数字只能放在一个单元格中，即使该单元格有多个候选数。</p>
        <p>步骤：</p>
        <ol>
          <li>检查每一行、列和宫格</li>
          <li>对于每个数字1-9，找出它在该行、列或宫格中可能出现的所有位置</li>
          <li>如果某个数字只有一个可能的位置，则该数字就是该位置的解</li>
        </ol>
        <p>这种方法需要更仔细的观察，但仍然是基础技巧。</p>
      `,
      example: `
        <p>例如，在某一行中，数字3只能放在一个特定的单元格中（因为其他位置都不能放3），那么这个单元格就应该填入3，即使这个单元格还有其他候选数。</p>
      `
    },
    {
      name: "候选数标记法",
      difficulty: 2,
      description: `
        <p>候选数标记法是一种辅助技巧，通过在每个空白单元格中标记所有可能的数字，帮助我们更容易地发现解题线索。</p>
        <p>步骤：</p>
        <ol>
          <li>对每个空白单元格，标记出所有可能的数字（1-9中不与同行、同列、同宫格冲突的数字）</li>
          <li>随着填入更多数字，不断更新候选数</li>
          <li>利用候选数的变化发现新的解题线索</li>
        </ol>
        <p>这种方法是其他高级技巧的基础。</p>
      `,
      example: `
        <p>例如，一个单元格的候选数是2,5,7，随着解题过程的推进，如果同行、同列或同宫格中有单元格填入了2和7，那么这个单元格的唯一候选数就是5。</p>
      `
    },
    {
      name: "区块摒除法",
      difficulty: 3,
      description: `
        <p>区块摒除法是指当某个数字在一个宫格内只能出现在某一行或某一列时，可以排除该行或该列在其他宫格中的该数字的可能性。</p>
        <p>步骤：</p>
        <ol>
          <li>找出某个宫格中，某个数字只能出现在同一行或同一列的单元格中</li>
          <li>排除该行或该列在其他宫格中的该数字的可能性</li>
        </ol>
        <p>这种方法需要更深入的分析和观察。</p>
      `,
      example: `
        <p>例如，如果在一个3x3宫格中，数字4只能出现在第二行的单元格中，那么第二行的其他宫格中就不可能出现数字4。</p>
      `
    },
    {
      name: "数对法",
      difficulty: 3,
      description: `
        <p>数对法是指当某一行、列或宫格中，有两个单元格的候选数完全相同且只有两个数字时，这两个数字只能出现在这两个单元格中，可以从其他单元格的候选数中排除这两个数字。</p>
        <p>步骤：</p>
        <ol>
          <li>找出某一行、列或宫格中，有两个单元格的候选数完全相同且只有两个数字</li>
          <li>从该行、列或宫格的其他单元格的候选数中排除这两个数字</li>
        </ol>
        <p>这种方法需要对候选数有清晰的标记和理解。</p>
      `,
      example: `
        <p>例如，如果在某一行中，有两个单元格的候选数都是2,7，那么这一行的其他单元格就不可能是2或7，可以从它们的候选数中排除这两个数字。</p>
      `
    },
    {
      name: "三数集法",
      difficulty: 4,
      description: `
        <p>三数集法是数对法的扩展，当某一行、列或宫格中，有三个单元格的候选数只包含相同的三个数字时，这三个数字只能出现在这三个单元格中，可以从其他单元格的候选数中排除这三个数字。</p>
        <p>步骤：</p>
        <ol>
          <li>找出某一行、列或宫格中，有三个单元格的候选数只包含相同的三个数字</li>
          <li>从该行、列或宫格的其他单元格的候选数中排除这三个数字</li>
        </ol>
        <p>这种方法比数对法更复杂，需要更细致的观察。</p>
      `,
      example: `
        <p>例如，如果在某一行中，有三个单元格的候选数都只包含1,3,9这三个数字，那么这一行的其他单元格就不可能是1,3或9，可以从它们的候选数中排除这三个数字。</p>
      `
    },
    {
      name: "X翼法",
      difficulty: 4,
      description: `
        <p>X翼法是指当某个数字在两行中都只能出现在相同的两列时，可以排除这两列在其他行中的该数字的可能性。</p>
        <p>步骤：</p>
        <ol>
          <li>找出某个数字在两行中都只能出现在相同的两列</li>
          <li>排除这两列在其他行中的该数字的可能性</li>
        </ol>
        <p>这种方法需要对整个数独盘面有全局的观察和理解。</p>
      `,
      example: `
        <p>例如，如果数字5在第2行只能出现在第3列和第7列，在第6行也只能出现在第3列和第7列，那么第3列和第7列的其他行就不可能出现数字5。</p>
      `
    },
    {
      name: "矩形顶点法",
      difficulty: 5,
      description: `
        <p>矩形顶点法是指当四个单元格形成一个矩形，且这四个单元格中有两个数字交替出现时，可以利用这一特性排除其他单元格的候选数。</p>
        <p>步骤：</p>
        <ol>
          <li>找出形成矩形的四个单元格，其中对角线上的单元格候选数相同</li>
          <li>如果这四个单元格中只有两个数字交替出现，可以排除同行、同列或同宫格中其他单元格的这两个数字</li>
        </ol>
        <p>这是一种高级技巧，需要深入理解数独的结构和规则。</p>
      `,
      example: `
        <p>例如，如果在(1,3)、(1,7)、(5,3)、(5,7)这四个位置形成一个矩形，且它们的候选数都只有2和8，那么第1行、第5行、第3列和第7列的其他单元格就不可能出现2或8。</p>
      `
    }
  ];

  /**
   * 获取难度文本
   * @param {number} level - 难度级别
   * @returns {string} 难度文本
   */
  const getDifficultyText = (level) => {
    const difficultyTexts = {
      1: '简单',
      2: '中等',
      3: '困难',
      4: '专家',
      5: '大师'
    };
    return difficultyTexts[level] || '未知';
  };

  return {
    currentTechniqueIndex,
    techniques,
    getDifficultyText
  };
}